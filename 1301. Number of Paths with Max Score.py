# 正方形棋盘(长度至少2），从右下角走到左上角（这两个点可通过且无数字），每次可以选择（左，上，左上）3个方向中的一个走一步
# 棋盘上X代表障碍不可通过，数字代表可以通过且能收集的数字
# 返回一个list：两个数字，第一个代表可收集的数字之和最大值，第二个代表能收集到此最大值的所有路径的总数
# 举例：
# E 1 2
# 1 X 1
# 2 1 S
# 最大可收集数字之和为4，共有2条路径可以得到4
# corner case：没有能到达左上角的路径时返回[0,0]

# 读题思考：可以使用62，63，64题的思路
# 62：dp找无障碍地图中路径总数
# 63：dp找有障碍的图中路径总数
# 64：dp找无障碍的图中权重最轻的路径的权重
# 1301：dp找有障碍的图中权重最重的路径的权重以及此权重的路径数量
# follow up：此题中同时记录所有路径


class Solution:
    def pathsWithMaxScore(self, A: List[str]) -> List[int]:
        n = len(A) # 地图边长
        mod = 10**9 + 7
        
        # 3d list, 每个元素 = [maximum value to this cell, number of paths]
        dp = [[[-10**5, 0] for j in range(n + 1)] for i in range(n + 1)]
        
        # 起点总权重为0，共有一条路径获得0
        dp[n - 1][n - 1] = [0, 1]
        
        # 从右向左，从下网上
        for x in range(n)[::-1]:
            for y in range(n)[::-1]:
                # 障碍和起点不需要计算，因为已经给出了初始值
                if A[x][y] in 'XS': continue
                # 某个点的值可能来源有：右，下，右下
                for i, j in [[0, 1], [1, 0], [1, 1]]:
                    if dp[x][y][0] < dp[x + i][y + j][0]:
                        dp[x][y] = [dp[x + i][y + j][0], 0]
                    if dp[x][y][0] == dp[x + i][y + j][0]:
                        dp[x][y][1] += dp[x + i][y + j][1]
                # 更新自己的总权重
                dp[x][y][0] += int(A[x][y]) if x or y else 0
                
        return [dp[0][0][0] if dp[0][0][1] else 0, dp[0][0][1] % mod]
    
    """
    对答案的理解：
    1. 两个dp同时进行，一是找到路径最大权重，二是最大权重对应的路径总数
    2. 每走一步，取上一步最大权重，然后更新权重：和第64题相同逻辑
    3. 对于路径数的理解（即对第三层for循环中的两个if statement的理解）：
        1）刚进入for循环时，第一个if statement永远成立，当前cell会被更新为第一个邻居的权重，以及0条路径
        2）立刻进入第二个if statement，将第一个邻居的路径赋值给cell
        3）然后进入第二次和第三次循环，如果有更大的权重则更新权重并获得0条路径，再加上此邻居的路径
        4）最后循环结束后cell的权重为最重邻居的权重，路径总数为拥有此权重的所有邻居的路径之和
    """

    # follow up：如果想要获得路径，可以在获得整个dp list后，写个recursion
    #            寻找从起点到点[i,j]的所有路径中权重为dp[i,j]的路径